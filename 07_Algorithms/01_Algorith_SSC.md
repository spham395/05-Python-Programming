# Algorithmic, Searching, Sorting, and Complexity

**Resource**

## Learning Objectives

* Determine the rate of growth of the work of an algorithm in terms of its problem size
* Use big-O notation to describe the running time and memory usage of an algorithm
* Recognize the common rates of growth of work, or complexity classes – constant, logarithmic, linear, quadratic, and exponential
* Convert an algorithm to a faster version that reduces its complexity by an order of magnitude
* Describe how the sequential search and binary search algorithms work
* Describe how the selection sort and quicksort algorithms work

## Measuring Algorithms

* When choosing algorithms
  * You often have to settle for a space/time trade-off
* An algorithm can be designed to gain faster run times  
  * At the cost of using extra space (memory) or the other way around
* Space/time trade-off is more relevant for miniature devices

## Measuring Algorithm Efficiency

* Use the computer’s clock to obtain an actual run time
  * Process called benchmarking or profiling
* Starts by determining the time for several different data sets of the same size and then calculates the average time
* Next, similar data are gathered for larger and larger data sets
  * After several tests enough data are available to predict how the algorithm will behave for a data set of any size
* Code for a tester program is found on the following slide

## Measuring Algorithm Runtime
Under construction


## Counting Instructions

Under construction

## Measuring Memory used by an Algorithm

Under construction

## Complexity Analysis

Under construction

## Orders of Complexity

## Big-O-Notation

## Constant Proportionality

## Search Algorithms

## Search for the Minimum
  
  * Sequential Search of a List
  
  * Case Performances
  
  * Binary Search

## Comparing Data

## Sorting Algorithms
 
  * Basic Sort
 
  ***Selection Sort**

  ***Bubble Sort**
  
  ***Insertion Sort**
  
  ***Case Performance Revisited**
  
  ***Faster Sorting**
  
  ***Quicksort**
    
    **Quicksort Overview**
    
    **Implementation of Quicksort**
  
  ***Merge Sort**

**Exponetial Algorithm: Recursive Fibonacci**

**Converting Fibonacci to Linear**

**Summary**
  
