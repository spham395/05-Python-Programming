# Algorithmic, Searching, Sorting, and Complexity

**Resource**

## Learning Objectives

* Determine the rate of growth of the work of an algorithm in terms of its problem size
* Use big-O notation to describe the running time and memory usage of an algorithm
* Recognize the common rates of growth of work, or complexity classes â€“ constant, logarithmic, linear, quadratic, and exponential
* Convert an algorithm to a faster version that reduces its complexity by an order of magnitude
* Describe how the sequential search and binary search algorithms work
* Describe how the selection sort and quicksort algorithms work

## Measuring Algorithms

* When choosing algorithms
  * You often have to settle for a space/time trade-off

* An algorithm can be designed to gain faster run times  
  * At the cost of using extra space (memory) or the other way around

* Space/time trade-off is more relevant for miniature devices

### Measuring Algorithm Efficiency



### Measuring Algorithm Runtime**

**Counting Instructions**

**Measuring Memory used by an Algorithm**

**Complexity Analysis**

**Orders of Complexity**

**Big-O-Notation**

**Constant Proportionality**

**Search Algorithms**

***Search for the Minimum**
  
  ***Sequential Search of a List**
  
  ***Case Performances**
  
  ***Binary Search**

**Comparing Data**

**Sorting Algorithms**
 
  ***Basic Sort**
 
  ***Selection Sort**

  ***Bubble Sort**
  
  ***Insertion Sort**
  
  ***Case Performance Revisited**
  
  ***Faster Sorting**
  
  ***Quicksort**
    
    **Quicksort Overview**
    
    **Implementation of Quicksort**
  
  ***Merge Sort**

**Exponetial Algorithm: Recursive Fibonacci**

**Converting Fibonacci to Linear**

**Summary**
  
